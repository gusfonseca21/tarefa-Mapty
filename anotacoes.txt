// // Se√ß√£o 15: Mapty App: OOP, Geolocation, External Libraries, and more!

// // -> HOW TO PLAN A WEB PROJECT

// // Quando formos construir um projeto do zero precisamos sempre come√ßar pela fase de planejamento.

// // O conceito de User Stories √© bastante usado e √© muito bom para pequenos e m√©dios projetos: √© basicamente uma descri√ß√£o da funcionalidade da aplica√ß√£o da perspectiva do usu√°rio. √â uma vis√£o geral de alto n√≠vel de toda a aplica√ß√£o, que ajuda a determinar os recursos que precisar√£o ser implementados. Ent√£o, para vizualisarmos as diferentes a√ß√µes que os usu√°rios podem tomar e como o programa reage a essas a√ß√µes, fazemos um Flow Chart. Ent√£o pensamos como iremos construir essa aplica√ß√£o, na arquitetura do nosso projeto. Somente a√≠ podemos passar para a fase de desenvolvimento, onde escrevemos o c√≥digo em si.

// // User Stories: um formato comum que podemos usar para criar user stories √© "As a [type of user], i want [an action] so that [a benefit].", que responde a pergunta Quem?, O Qu√™? e Por Qu√™?

// // No exemplo do nosso aplicativo fica: Como um usu√°rio, quero registrar meus exerc√≠cios com localidade, dist√¢ncia, tempo, ritmo e passos por minuto, para que eu possa manter um registro de todas minhas corridas. Podemos fazer diversos user stories com diversos tipos de usu√°rios em mente diferentes e com objetivos diferentes.

// // Features: a partir do user stories podemos come√ßar a pensar nos recursos que precisaremos no desenvolvimento do aplicativo. No nosso aplicativo, precisaremos de um mapa para registrar a localidade dos exerc√≠cios, de geolocaliza√ß√£o para localizar a posi√ß√£o do usu√°rio, tamb√©m precisaremos de um formul√°rio em que ser√° preenchido com os dados dos exerc√≠cios, etc.

// // FlowChart: a partir dos features podemos criar a flowchart que ser√° uma previs√£o dos caminhos poss√≠veis que o usu√°rio poder√° tomar ao usar o aplicativo. √â normal n√£o pensar em todos os passos da flowchart no come√ßo do projeto, pode ser constru√≠da com mais detalhes no decorrer do projeto.

// // Arquitetura: assim como no flowchart, n√£o precisamos, j√° de cara, desenvolver uma arquitetura completa, vamos desenvolvendo-a no decorrer do projeto. No nosso aplicativo vamos come√ßar a escrever o c√≥digo, mas assim que precisamos de uma maior orgnaiza√ß√£o vamos desenvolver e pensar na arquitetura do projeto.

// // -> USING THE GEOLOCATION API

// // O Geolocation API √© um API do Browser, como timers ou internationalization. Tamb√©m temos brosers API que usam a c√¢mera do usu√°rio ou que fazem o celular vibrar.

// navigator.geolocation.getCurrentPosition(
//   function (position) {
//     const { latitude } = position.coords;
//     const { longitude } = position.coords;
//     console.log(`https://www.google.com.br/maps/@${latitude},${longitude}`);
//   },
//   function () {
//     alert('Could not get your position');
//   }
// );

// // No exemplo acima usamos a fun√ß√£o navigator.geolocation.getCurrentPosition() e nela temos duas fun√ß√µes como par√¢metros. A primeira ser√° executada caso o browser consiga as coordenadas do usu√°rio e a segunda caso o browser n√£o consiga as coordenadas.

// // -> DISPLAYING A MAP USING LEAFLET LIBRARY

// // Leaflet √© uma biblioteca third party que podemos usar para mostrar o mapa. Incorporaremos essa biblioteca no nosso c√≥digo usando o m√©todo de Hosted Version, onde copiamos o c√≥digo disponibilizado no site no nosso arquivo html, antes do script.js ser carregado e sempre colocando o atributo defer logo ap√≥s "<script" pois a ordem em que o script √© carregado nesse caso √© muito importante.

// // Para realmente usarmos a biblioteca temos que usar as fun√ß√ïes e methods definidos na pr√≥pria biblioteca. OBS: As vari√°veis dessa biblioteca estar√£o dispon√≠veis para todos os c√≥digos atrelados √† biblioteca, desde que esses outros scripts sejam carregados depois (heran√ßa).

// if (navigator.geolocation)
//   navigator.geolocation.getCurrentPosition(
//     function (position) {
//       const { latitude } = position.coords;
//       const { longitude } = position.coords;

//       const coords = [latitude, longitude];

//       const map = L.map('map').setView(coords, 13);

//       L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
//         attribution:
//           '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
//       }).addTo(map);

//       L.marker(coords)
//         .addTo(map)
//         .bindPopup('A pretty CSS3 popup.<br> Easily customizable.')
//         .openPopup();
//     },
//     function () {
//       alert('Could not get your position');
//     }
//   );

// // Em L.tileLayer() estamos usando openstreetmap que √© um c√≥digo open source de mapas e onde podemos escolher diversos estilos de mapas.

// // -> DISPLAYING A MAP MARKER

// // N√£o podemos simplesmente adicionar um event handler em todo o elemento do mapa pois assin n√£o saber√≠amos onde exatamente o usu√°rio clicou no mapa, as coordenadas do gps do local que foi clicado. Por isso vamos usar um event handler provido pelo leaflet. √â para isso que estamos usando a vari√°vel map para guardar as informa√ß√µes da localidade mostrada no mapa:

// map.on('click', function (mapEvent) {
//   const { lat, lng } = mapEvent.latlng;
//   L.marker([lat, lng])
//     .addTo(map)
//     .bindPopup(
//       L.popup({
//         maxWidth: 250,
//         minWidth: 100,
//         autoclose: false,
//         closeOnClick: false,
//         className: 'running-popup',
//       })
//     )
//     .setPopupContent('Workout')
//     .openPopup();
// });

// // Acima temos um exemplo da marca√ß√£o no mapa usando o que a documenta√ß√£o do leaflet nos diz para podermos customizar as marca√ß√µes. Abaixo o c√≥digo acima estar√° inserido dentro do resto do c√≥digo do leaflet no nosso aplicativo:

// // -> RENDERING WORKOUT INPUT FORM

// let map, mapEvent;

// map.on('click', function (mapE) {
//   mapEvent = mapE;
//   form.classList.remove('hidden');
//   inputDistance.focus();
// });

// form.addEventListener('submit', function (e) {
//   e.preventDefault();
//   inputDistance.value =
//     inputDuration.value =
//     inputCadence.value =
//     inputElevation.value =
//       '';
//   const { lat, lng } = mapEvent.latlng;
//   L.marker([lat, lng])
//     .addTo(map)
//     .bindPopup(
//       L.popup({
//         maxWidth: 250,
//         minWidth: 100,
//         autoClose: false,
//         closeOnClick: false,
//         className: 'running-popup',
//       })
//     )
//     .setPopupContent('Workout')
//     .openPopup();
// });

// inputType.addEventListener('change', function () {
//   inputElevation.closest('.form__row').classList.toggle('form__row--hidden');
//   inputCadence.closest('.form__row').classList.toggle('form__row--hidden');
// });

// // -> PROJECT ARCHITECTURE

// // Vamos usar OOP (Object Oriented Classes) para organizar o nosso c√≥digo. No nosso aplicativo a nossa estrutura principal vir√° de classes e objetos.

// // Um dos aspectos mais importantes relacionados a arquitetura de um projeto √© decidir onde e como os dados ser√£o armazenados. Os dados s√£o a parte mais fundamental de qualquer aplica√ß√£o.

// // Do user stories vemos que, por exemplo, teremos que armazenar os dados de localidade, dist√¢ncia, tempo, ritmo e cad√™ncia, al√©m de outros. Considerando que temos dois tipos de exerc√≠cios poss√≠veis em nosso aplicativo (corrida e bicicleta), teremos uma classe principal (Workout) que ter√° dados que os dois tipos de exerc√≠cios ir√£o compartilhar, mas teremos classes mais espec√≠ficas para exerc√≠cio com seus dados espec√≠ficos.

// // A partir do nosso flowchart tamb√©m temos as a√ß√µes que precisam ser feitas em nosso c√≥digo para que o aplicativo funcione. A partir delas vamos criar uma grande classe chamada App que ir√° conter todas essas fun√ß√µes como methods.

// // -> REFACTORIGN FOR PROJECT ARCHITECTURE

// // Vamos implementar a classe App:

// class App {
//   #map;
//   #mapEvent;
//   constructor() {
//     this._getPosition();
//     form.addEventListener('submit', this._newWorkout.bind(this));
//     inputType.addEventListener('change', this._toggleElevationField);
//   }

//   _getPosition() {
//     if (navigator.geolocation)
//       navigator.geolocation.getCurrentPosition(
//         this._loadMap.bind(this),
//         function () {
//           alert('Could not get position!');
//         }
//       );
//   }

//   _loadMap(position) {
//     const { latitude } = position.coords;
//     const { longitude } = position.coords;

//     const coords = [latitude, longitude];

//     this.#map = L.map('map').setView(coords, 14);

//     L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
//       attribution:
//         '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
//     }).addTo(this.#map);
//     this.#map.on('click', this._showForm.bind(this));
//   }
//   _showForm(mapE) {
//     this.#mapEvent = mapE;
//     form.classList.remove('hidden');
//     inputDistance.focus();
//   }

//   _toggleElevationField() {
//     inputElevation.closest('.form__row').classList.toggle('form__row--hidden');
//     inputCadence.closest('.form__row').classList.toggle('form__row--hidden');
//   }

//   _newWorkout(e) {
//     e.preventDefault();
//     inputDistance.value =
//       inputDuration.value =
//       inputCadence.value =
//       inputElevation.value =
//         '';
//     const { lat, lng } = this.#mapEvent.latlng;
//     L.marker([lat, lng])
//       .addTo(this.#map)
//       .bindPopup(
//         L.popup({
//           maxWidth: 250,
//           minWidth: 100,
//           autoClose: false,
//           closeOnClick: false,
//           className: 'running-popup',
//         })
//       )
//       .setPopupContent('Workout')
//       .openPopup();
//   }
// }

// const app = new App();

// // -> MANAGING WORKOUT DATA: CREATING CLASSES

// // Vamos implementar classes para gerir os dados sobre os exerc√≠cios de corrida e de bicicleta que est√£o vindo da interface do usu√°rio.

// // Implementaremos a classe-pai da classe dos exerc√≠cios:

// class Workout {
//   date = new Date();
//   id = (Date.now() + '').slice(-10);

//   constructor(coords, distance, duration) {
//     this.coords = coords;
//     this.distance = distance;
//     this.duration = duration;
//   }
// }

// class Running extends Workout {
//   constructor(coords, distance, duration, cadence) {
//     super(coords, distance, duration);
//     this.cadence = cadence;
//     this.calcPace();
//   }
//   calcPace() {
//     this.pace = this.duration / this.distance;
//     return this.pace;
//   }
// }

// class Cycling extends Workout {
//   constructor(coords, distance, duration, elevationGain) {
//     super(coords, distance, duration);
//     this.elevationGain = elevationGain;
//     this.calcSpeed();
//   }
//   calcSpeed() {
//     this.speed = this.distance / (this.duration / 60);
//     return this.speed;
//   }
// }

// // -> CREATING A NEW WORKOUT

// // Usando as classes workout que acabamos de criar, vamos implementar o recurso de criar um novo workout usando a interface de usu√°rio. Na classe de App, no method _newWorkout:

// #workouts = []; // Esse c√≥digo na classe App

// e.preventDefault();

// const validInputs = (...inputs) => inputs.every(inp => Number.isFinite(inp));
// const allPositive = (...inputs) => inputs.every(inp => inp > 0);

// const type = inputType.value;
// const distance = +inputDistance.value;
// const duration = +inputDuration.value;
// const { lat, lng } = this.#mapEvent.latlng;
// let workout;

// if (type === 'running') {
//   const cadence = +inputCadence.value;
//   if (
//     !validInputs(distance, duration, cadence) ||
//     !allPositive(distance, duration, cadence)
//   )
//     return alert('Inputs have to be positive numbers!');

//   workout = new Running([lat, lng], distance, duration, cadence);
// }

// if (type === 'cycling') {
//   const elevation = +inputElevation.value;
//   if (
//     !validInputs(distance, duration, elevation) ||
//     !allPositive(distance, duration)
//   )
//     return alert('Inputs have to be positive numbers!');
//     workout = new Cycling([lat, lng], distance, duration, elevation)
// }

// this.#workouts.push(workout);
// this.renderWorkoutMarker(workout);

// _renderWorkoutMarker(workout) {  // Criando um method
//     L.marker(workout.coords).addTo(this.#map).bindPopup(L.popup({maxWidth: 250, minWidth: 100, autoClose: false, closeOnClock: false, className: `${workout.type}-popup`,})).setPopupContent(workout.distance).openPopup();
// }


// // Na classe de Cycling e Running, antes de constructor:

// class Running extends Workout {
//     type = 'running';

// class Cycling extends Workout {
//     type = 'cycling';


// // -> RENDERING WORKOUTS

// // Primeiramente vamos criar um novo method na classe App e que ser√° chamado pelo method _newWorkout:

// this._renderWorkout(workout) // No Method _newWorkout

// _renderWorkout(workout) {
//   let html = `
//     <li class="workout workout--${workout.type}" data-id="${workout.id}">
//             <h2 class="workout__title">${workout.description}</h2>
//             <div class="workout__details">
//               <span class="workout__icon">${workout.type === 'running' ? 'üèÉ‚Äç‚ôÇÔ∏è' : 'üö¥‚Äç‚ôÄÔ∏è'}</span>
//               <span class="workout__value">${workout.distance}</span>
//               <span class="workout__unit">km</span>
//             </div>
//             <div class="workout__details">
//               <span class="workout__icon">‚è±</span>
//               <span class="workout__value">${workout.duration}</span>
//               <span class="workout__unit">min</span>
//             </div>
//             `;
//             if (workout.type === 'running') 
//               html + `
//               <div class="workout__details">
//               <span class="workout__icon">‚ö°Ô∏è</span>
//               <span class="workout__value">${workout.pace.toFixed(1)}</span>
//               <span class="workout__unit">min/km</span>
//             </div>
//             <div class="workout__details">
//               <span class="workout__icon">ü¶∂üèº</span>
//               <span class="workout__value">${workout.cadence}</span>
//               <span class="workout__unit">spm</span>
//             </div>
//             </li>
//             `;
//             if (workout.type === 'cycling')
//             html += `
//             <div class="workout__details">
//             <span class="workout__icon">‚ö°Ô∏è</span>
//             <span class="workout__value">${workout.speed.toFixed(1)}</span>
//             <span class="workout__unit">km/h</span>
//           </div>
//           <div class="workout__details">
//             <span class="workout__icon">‚õ∞</span>
//             <span class="workout__value">${workout.elevationGain}</span>
//             <span class="workout__unit">m</span>
//           </div>
//           </li>
//             `;

//             form.insertAdjacentHTML('afterend', html);
// }

// // Para gerar a string a ser mostrada no c√≥digo acima, no t√≠tulo da barra de workout, criaremos um novo method na classe Workout:

// _setDescription() {
//   // prettier-ignore
//   const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  
//   this.description = `${this.type[0].toUppercase()}${this.type.slice(1)} on ${months[this.date.getMonth()]} ${this.date.getDate()}`;
// }

// // Depois disso devemos colocar this.setDescription() no constructor de cada child-class:

// class Running extends Workout {
//   type = 'running';
//   constructor(coords, distance, duration, cadence) {
//     super(coords, distance, duration);
//     this.cadence = cadence;
//     this.calcPace();
//     this._setDescription();
//   }
// }

// // Vamos criar mais um method na classe App para esconder o formul√°rio quando n√£o estivermos adicionando informa√ß√µes sobre exerc√≠cios:

// _hideForm() {
//   inputDistance.value = inputDuration.value = inputCadence.value = inputElevation.value = '';
//   form.style.display = 'none';
//   form.classList.add('hidden');
//   setTimeout(() => form.style.display = 'grid', 1000);
// }

// // -> MOVE TO MARKER ON CLICK

// // Vamos implementar a fun√ß√£o de mover o para para a localiza√ß√£o da marca√ß√£o quando clicamos na marca√ß√£o na barra do lado.

// containerWorkouts.addEventListener('click', this._moveToPopup.bind(this)); // No container da classe App

// // Agora criando um method na classe App:

// _moveToPopup(e) {
//   const workoutEl = e.target.closest('.workout');

//   if (!workoutEl) return;

//   const workout = this.#workouts.find(work => work.id === workoutEl.dataset.id);

//   this.#map.setView(workout.coords, this.#mapZoomLevel, {
//     animate: true,
//     pan: {
//       duration: 1
//     }
//   }) 
// }

// // -> WORKING WITH LOCALSTORAGE

// // Vamos usar o API LocalStore para armazenarmos os dados do nosso aplicativo.

// // No method _newWorkout:
// this._setLocalStorage();

// // Criando o method _setLocalStorage:

// _setLocalStorage() {
//   localStorage.setItem('workouts',  JSON.stringify(this.#workouts))
// }

// // Com a fun√ß√£o JSON.stringify() transformamos um objeto em string.

// // No constructor da classe App (onde o nosso aplicativo √© incializado) vamos fazer o carregamento dos dados salvos:

// this._getLocalStorage();

// // Criando o method:

// _getLocalStorage() {
//   const data = JSON.parse(localStorage.getItem('workouts'));

//   if (!data) return;

//   this.#workouts = data;
//   this.#workouts.forEach(work => {
//     this._renderWorkout(work);
//   })
// }

// // JSON.parse() transforma uma string em um objeto. OBS: Quando transformamos objetos em strings e os tranformamos de volta em objetos, esse objeto perde a sua heran√ßa de methods.

// // Como uma marca√ß√£o s√≥ pode ser mostrada no mapa depois do mapa ter sido totalmente carregado, e o carregamento dos dados acontece bem no come√ßo, precisamos fazer com que os dados s√≥ possam ser carregados ap√≥s o carregamento do mapa:

// // No method _loadMap:

// this.#workouts.forEach(work => {
//   this._renderWorkout(work);
//   this._renderWorkoutMarker(work);
// })

// // Vamos criar um method para limpar os dados do local storage:

// reset() {
//   localStorage.removeItem('workouts');
//   location.reload()
// }

// // -> FINAL CONSIDERATIONS

// // Implementar a habilidade de editar, deletar e deletar todos os exerc√≠cios.
// // Implementar a habilidade de ordenar os exerc√≠cios por dist√¢ncia, dura√ß√£o, etc.
// // Reconstruir os objetos running e cycling que est√£o vindo do local storage (que perderam sua natureza de objeto running ou cycling)
// // Implementar mensagens de erro e confirma√ß√£o mais realistas.
// // Adicionar a habilidade de posicionar o mapa para mostrar todos os exerc√≠cios (um bot√£o). Depender√° da leitura da documenta√ß√£o do Leaflet.
// // Adicionar a habilidade de desenhar linhas e formas ao inv√©s de somente pontos no mapa.


// _workoutEdit(e) {
//   const workoutEditEl = e.target.closest('.workout');
//   const workoutEdit = this.#workouts.find(
//     work => work.id === workoutEditEl.dataset.id
//   );
//   let distance = prompt('Distance: ');
//   while (distance === null) distance;
//   let duration = prompt('Duration: ');
//   if (duration === null) duration = workoutEdit.duration;
//   workoutEdit.distance = distance;
//   workoutEdit.duration = duration;

//   if (workoutEdit.type === 'running') {
//     let cadence = prompt('Cadence: ');
//     if (cadence === null) workoutEdit.cadence = cadence;
//     workoutEdit.cadence = cadence;
//     let pace = duration / cadence;
//     workoutEdit.pace = pace;

//     if (workoutEdit.type === 'cycling') {
//     }

//     this.#workouts.forEach((workout, index) => {
//       if (workout.id === workoutEdit.id) {
//         this.#workouts.splice(index, 1, workoutEdit);
//         this._setLocalStorage();
//         window.location.reload();
//       }
//     });
//   }
// }